package com.ltu.sdk.handlers;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.reflect.TypeToken;
import com.ltu.sdk.resources.ApiResourceData;
import com.ltu.sdk.resources.Match;
import com.ltu.sdk.resources.MetaData;
import com.ltu.sdk.resources.PaginatedResult;
import com.ltu.sdk.resources.Project;
import com.ltu.sdk.resources.Query;
import com.ltu.sdk.resources.images.Image;
import com.ltu.sdk.resources.visuals.Visual;

/**
 * This class allows to handle paginated response from the API.
 *
 * Usage:
 *
 * <pre>
 * PaginatedResponseHandler&lt;MyClass&gt; handler = new PaginatedResponseHandler&lt;MyClass&gt;(
 *         MyClass.class) {
 *     &#064;Override
 *     protected void onSuccess(PaginatedResult&lt;MyClass&gt; paginatedResult) {
 *         Pagination pagination = paginatedResult.getPagination();
 *         // Do something clever with the results
 *         List&lt;MyClass&gt; result = paginatedResult.getResult();
 *     }
 * };
 * </pre>
 *
 * The trick of passing the class of T in the constructor is mandatory since the
 * class of T cannot be inferred at runtime.
 *
 * @param <T>
 *            The type of object to be un-serialize from the HTTP response
 */
public abstract class PaginatedResponseHandler<T extends ApiResourceData>
        extends ApiResourceHandler<T> {

    /**
     * Maps all ApiResources that can be paginated to their GSON type for
     * un-serialization.
     */
    private static Map<Class<? extends ApiResourceData>, Type> map = new HashMap<Class<? extends ApiResourceData>, Type>() {

        /**
         * Required field serialization- auto generated by Eclipse
         */
        private static final long serialVersionUID = -8530682730740209562L;

        /**
         * Static block to initialize the map, all ApiResources that can be
         * paginated should be here. Also see: http://ltu.fr/Kc for using
         * generics in GSON
         */
        {
            this.put(Project.class, new TypeToken<PaginatedResult<Project>>() {
            }.getType());
            this.put(Match.class, new TypeToken<PaginatedResult<Match>>() {
            }.getType());
            this.put(Query.class, new TypeToken<PaginatedResult<Query>>() {
            }.getType());
            this.put(MetaData.class,
                    new TypeToken<PaginatedResult<MetaData>>() {
                    }.getType());
            this.put(Visual.class, new TypeToken<PaginatedResult<Visual>>() {
            }.getType());
            this.put(Image.class, new TypeToken<PaginatedResult<Image>>() {
            }.getType());
        }
    };

    public PaginatedResponseHandler(Class<T> genericType) {
        super(genericType);
    }

    /**
     * Retrieve the {@link Type} to use when un-serializing a paginated result.
     *
     * @param key
     *            Class of the object we want to receive from the API
     * @return a {@link Type} that can be un-serialized by GSON
     */
    private Type get(Class<? extends ApiResourceData> key) {
        return PaginatedResponseHandler.map.get(key);
    }

    /**
     * Override this method to handle the object returned by the API
     *
     * @param paginatedResult
     *            The object received from the API
     */
    protected abstract void onResultReceived(PaginatedResult<T> paginatedResult);

    /**
     * When we receive a response from the API we un-serialize it to the type
     * this {@link PaginatedResponseHandler} has been created with and then call
     * the method onResultReceived(PaginatedResult<T> result) letting the caller
     * handle only high level objects.
     *
     * @param response
     *            The text response from the API
     */
    @Override
    public void onSuccess(String response) {
        Type type = this.get(this.genericType);
        if (type == null) {
            StringBuilder errorMessage = new StringBuilder(
                    "No Type associated with ")
                    .append(this.genericType.getCanonicalName())
                    .append(". Did you add an entry in the mapping of ")
                    .append(this.getClass().getCanonicalName()).append("?");
            this.onFailure(new Throwable(), errorMessage.toString());
        }
        PaginatedResult<T> result = gson.fromJson(response, type);
        if (result != null) {
            this.onResultReceived(result);
        } else {
            StringBuilder errorMessage = new StringBuilder(
                    "Couldn't retrieve object of type ")
                    .append(this.genericType.getCanonicalName());
            this.onFailure(new Throwable(), errorMessage.toString());
        }
    }
}
